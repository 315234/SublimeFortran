%YAML 1.2
---
name: Fortran (Modern)
file_extensions: [f90, F90, f95, F95, f03, F03, f08, F08]
scope: source.modern-fortran

variables:
  ident: '[A-Za-z_][A-Za-z_0-9]*'
  type: |
    (?xi)
    (?:
        \b integer            \b
      | \b real               \b
      | \b complex            \b
      | \b logical            \b
      | \b character \* \(\*\)
      | \b character          \b
      | \b double\s+precision \b
      | \b type \s* \(
                        \s* [\w]+ \s*
                    \)
    )
  modifier: '(?xi:elemental|pure|impure|recursive|module)'
  attribute: |
    (?xi)
    (?:
        allocatable
      | pointer
      | target
      | equivalence
      | parameter
      | external
      | intrinsic
      | save
      | optional
      | contiguous
      | private
      | public
      | protected
    )
  # linecont: '(?x:\s* & \s* (!.*)? $ \n?)' # matches possible space, amersand, possible space, possible comment, end of line, possible newline
  formatdescr: (?xi:(\d+)?  (/|pe|[aeigfxp])  (\d+)?  \.?  (\d+)? )
  escapeseq: (?xi:\\ [nrtbfv0''"x\\] )













contexts:
  main:
    - include: comments
    - include: illegal
    - include: m4-macros
    - include: strings
    - include: use-statement
    - include: implicit-statement
    - include: openmp
    - include: enumerator
    - include: program-units
    - include: flow-control
    - include: misc-keywords
    - include: user-defined-types
    - include: format-statement
    - include: labelled-statements
    - include: data-type-attributes
    - include: io
    - include: allocation
    - include: preprocessor
    - include: namelist
    - include: common-block
    - include: data-statement
    - include: block-data-statement
    - include: public-private-protected
    - include: coarrays
    - include: associate-block
    - include: ieee-intrinsics
    - include: nullify-statement
    - include: fortran-2008
    - include: ieee-intrinsic-modules
    - include: generic-subroutine-call



  comments:
    # comments
    - match: \!
      push: comment
  illegal:
    # tabs are illegal
    - match: \t
      scope: invalid.illegal.tab.fortran

  m4-macros:
    # M4 macro quoted strings, comments, variables and macro definitions
    - match: \`
      push: m4macrostring
    - match: (?x:\b dnl \b )
      push: comment
    - match: \$\d+
      scope: variable.parameter.m4.fortran
    - match: |
        (?x)
        (?:
          \b
          (define)
          \(
          \s*
          `(\w+)'
        )
      captures:
        1: keyword.m4.define.fortran
        2: entity.name.function.m4.fortran

  strings:
    - match: \'
      push: singlestring
    - match: (\")
      push: doublestring

  use-statement:
    # use statements etc
    - match: |
        (?xi)
        (?:^
          \s* (use)
          \s+ (\w+)
          ( (,) \s* (only) \s* (:) )?
        )
      captures:
        0: use.statement.fortran
        1: keyword.use.fortran
        2: storage.type.module.fortran
        3: optional.group.use.statement.fortran
        5: keyword.only.fortran

  implicit-statement:
    # implicit statement
    - match: |
        (?xi)
        (?:
          (implicit)
          \s+
          (none|.*)
        )
      captures:
        0: implicit.statement.fortran
        1: keyword.implicit.fortran
        2: meta.implicit-specification.fortran


  openmp:
    # OpenMP
    - match: (?x:^  \s*  ([!]\$)  .*  $)
      scope: support.other.openmp.fortran

  enumerator:
    # enum
    - match: |
        (?xi)
        (?:^
          \s* (
            enum
            (,\s*bind\(c\))?)
          \s*
          $
        )
      captures:
        1: keyword.enum.fortran

    - match: (?xi:\b enumerator \b)
      scope: keyword.enumerator.fortran
    # end enum
    - match: (?xi:^  \s*  (endenum) \b)
      captures:
        1: keyword.enum.fortran

  program-units:
    # program definition
    - match: |
        (?xi)
        (?:^
          \s* (program)
          \s+ ({{ident}})
          \s*
          $
        )
      captures:
        1: keyword.program-unit.fortran
        2: entity.name.function.program.fortran

    # type definition
    - match: |
        (?xi)
        (?:^
          \s* (type)
          (\s*::\s*|\s+)
          (\w+)
          \s*
          $
        )
      captures:
        1: keyword.type.fortran
        2: keyword.operator.fortran
        3: entity.name.function.type.fortran

    # module definition
    - match: |
        (?xi)
        (?:^
          \s* (module)
          \s+  (\w+)
          \s*
          $
        )
      captures:
        1: keyword.program-unit.fortran
        2: entity.name.function.module.fortran

    # submodule definition
    - match: |
        (?xi)
        (?:^
          \s* (submodule)
          \s* \( ({{ident}}) \)
          \s* ({{ident}})
          \s*
          $
        )
      captures:
        1: keyword.submodule.fortran
        2: variable.other.module.fortran
        3: entity.name.function.module.fortran

    # interface with name
    - match: |
        (?xi)
        (?:
          (?<!end)
          (interface) \b
          \s* ({{ident}})?
          \s*
          $
        )
      captures:
        1: keyword.program-unit.fortran
        2: entity.name.function.fortran
      # push: interface

    # function/subroutine definition with parameter list
    - match: |
        (?xi)
        (?:^
          \s*
          ((?:{{modifier}}\s+)*)
          ({{type}}\s+)?
          (?<!end)
          \b (function|subroutine) \b
          \s+ ({{ident}})
          \s* (\(|&)
        )
      scope: meta.subroutine-declaration.fortran
      captures:
        1: keyword.modifier.fortran
        2: storage.type.fortran
        3: keyword.program-unit.fortran
        4: entity.name.function.fortran
      push: subroutine_parameter_list

    # function/subroutine definition without parameter list
    - match: |
        (?xi)
        (?:^
          \s*
          ((?:{{modifier}}\s+)*)
          ({{type}}\s+)?
          (?<!end)
          \b (function|subroutine) \b
          \s+
          ({{ident}})
          \s*
        )
      scope: meta.subroutine-declaration.fortran
      captures:
        1: keyword.modifier.fortran
        2: storage.type.fortran
        3: keyword.program-unit.fortran
        4: entity.name.function.fortran
      # push: subroutines

    # end with block type and possible identifier
    - match: |
        (?xi)
        (?:^
          \s* (end) \b
          ( \s+ (?:function|subroutine|module|submodule|type|interface|program|type) )?
          ( \s+ {{ident}} )?
        )
      scope: meta.end-statement.fortran
      captures:
        1: keyword.control.end.fortran
        2: keyword.program-unit.fortran
        3: entity.name.function.fortran




  flow-control:
    # if statement
    - match: |
        (?xi)
        (?:^ \s*
          (if|else\s*if|elif|endif)  \b  
        )
      scope: keyword.control.fortran
    # select case statement
    - match: |
        (?xi)
        (?:^ \s*
          (select\s+case)  \b  
        )
      scope: keyword.control.fortran
    - match: |
        (?xi)
        (?:^ \s*
          (case)  .*  (:)  \b  
        )
      captures:
        1: keyword.control.fortran
    # where/forall statement
    - match: |
        (?xi)
        (?:^ \s*
          (where|elsewhere|forall|endwhere|endforall)  \b  
        )
      scope: keyword.control.fortran
    # do loop (with optional label and number)
    - match: |
        (?xi)
        (?:^ \s*
          (?:(\w+):\s*)? (do \s+ concurrent|do) \b
          (\s+\d+\s+)?
          \s*
        )
      captures:
        1: entity.name.tag.do-loop-label.fortran
        2: keyword.control.fortran
        3: entity.name.statement-label.fortran

    # statements controling the flow of the program
    - match: |
        (?xi)
        (?:
          \b( assign
            | to
            | if
            | then
            | else
            | elseif
            | elif
            | case
            | continue
            | stop
            | pause
            | do
            | while
            | cycle
            | exit
            | select \s* case
            | error \s+ stop
            | end \s* select
            | end \s* if
            | end \s* do
            ) \b
        )
      scope: keyword.control.fortran












  misc-keywords:
    # contains
    - match: (?xi:\b contains \b)
      scope: keyword.other.contains.fortran
    # programming units
    - match: \b(?i:(entry|return|include))\b
      scope: keyword.control.programming-units.fortran
    # other
    - match: \b(?i:(operator|assignment))\b
      scope: storage.type.fortran

  user-defined-types:
    # types
    - match: "{{type}}"
      scope: storage.type.fortran
    # user defined types
    - match: \b(?i:(type\([\s\w]+\)))\b
      scope: storage.type.fortran



  labelled-statements:
    # continue label, possibly numbered
    - match: (?xi:^  \s*  (\d+)?  \s*  (continue)  \s*  $)
      captures:
        0: meta.continue-label.fortran
        1: entity.name.statement-label.fortran
        2: keyword.continue.fortran
    # labeled statement
    - match: ^(    \d|   \d\d|  \d\d\d)
      scope: entity.name.statement-label.fortran
    # goto statement
    - match: (?xi:\b  (go\s*to)  \s+  (\d+))
      captures:
        1: keyword.goto.fortran
        2: entity.name.statement-label.fortran


  data-type-attributes:
    # data type attributes
    - match: \b(?i:{{attribute}})\b
      scope: storage.modifier.fortran
    # dimension statement
    - match: (?xi:^  \s*  (dimension)  \b  )
      captures:
        1: storage.modifier.fortran
    # variable dimension
    - match: (?xi:\b  (dimension)  \s* \(  [^)]*  \)  )
      captures:
        0: meta.dimension.fortran
        1: storage.modifier.fortran
    # variable intent
    - match: (?xi:\b  (intent)  \s* \(  \s*  (in|out|inout)  \s*  \)  )
      captures:
        0: meta.intent.fortran
        1: keyword.intent.fortran
        2: constant.language.fortran

  io:
    # IO: open, close
    - match: (?xi:\b  (close|open)  \s*  \(  )
      captures:
        1: support.function.fortran

    # IO: print with format string
    - match: (?xi:\b  (print)  \s*  ( \") )
      captures:
        1: support.function.fortran
        2: string.quoted.double.fortran
      push: inside-format-string
    # IO: print with format string variable or star or number
    - match: (?xi:\b  (print)  \s*  (\*)? (\d+)? (\w+)? )
      captures:
        1: support.function.fortran
        2: keyword.default-format.fortran
        3: variable.format-number.fortran
        4: variable.format-string.fortran
    # IO: write with (unit number|string variable) and format string
    - match: (?xi:\b  (write)  \s*  (\() (\d+|{{ident}}) \s* , \s*      ( \"\( )  )
      captures:
        1: support.function.fortran
        2: punctuation.parenthesis.fortran
        3: variable.write-destination.fortran
        4: punctuation.start-of-format-string.fortran meta.format-string.fortran
      push: formatstring
    # IO: write with (unit number|string variable) and format string variable or star or number
    - match: (?xi:\b  (write)  \s*  (\() (\*|\d+|{{ident}}) \s* , \s*      (\*)? (\d+)? (\w+)? )
      captures:
        1: support.function.fortran
        2: punctuation.parenthesis.fortran
        3: variable.write-destination.fortran
        4: keyword.default-format.fortran
        5: variable.format-number.fortran
        6: variable.format-string.fortran
    
    # IO: print, write, rewrite, read
    - match: (?xi:\b  (print|write|rewrite|read)  \s*  (?= ( \( | \* | \d+ ) )  )
      captures:
        1: support.function.fortran

    # IO: pause, wait, rewind, flush, inquire
    - match: (?xi:\b  (pause|wait|rewind|flush|inquire)  \s*  \(  )
      captures:
        1: support.function.fortran


  format-statement:
    # IO: format statement
    - match: (?xi:^  \s*  (\d+)  \s+  (format)  \s*  (\()  )
      captures:
        1: entity.name.statement-label.fortran
        2: keyword.format.fortran
        3: open-format-group.fortran
      push: inside-format-group

    # # IO: other format string
    # - match: (\")(\() # "( ... )"
    #   captures: 
    #     1: punctuation.start-of-format-string.fortran
    #     2: open-format-group.fortran
    #   push: inside-format-group

  inside-format-string:
    - meta_content_scope: meta.inside-format-string.fortran
    - match: \(
      scope: open-format-group.fortran
      push: inside-format-group
    - match: \"
      scope: string.quoted.double close-format-string.fortran
      pop: true
  inside-format-group:
    # Represents the content between two () in a format group
    - meta_content_scope: meta.inside-format-group.fortran
    - include: strings
    - match: \(
      scope: open-format-group.fortran
      push: inside-format-group
    - match: '\d+(?=\()'
      scope: constant.numeric.format-string-group-multiplier.fortran
    - match: \)
      pop: true
      scope: close-format-group
    - match: '{{formatdescr}}'
      scope: constant.numeric.format-descriptor.fortran





  allocation:
    # allocate, deallocate
    - match: (?xi:\b  (allocate|deallocate)  \b  \s*  \(  \s*  (\w+)  )
      captures:
        1: support.function.fortran
        2: variable.other.fortran

  preprocessor:
    # preprocessor logic
    - match: (?xi:^  \s*  \#  \s*  (define|undef|if|ifdef|elif|ifndef|else|endif)  \b  .*  $)
      scope: keyword.control.preprocessor.fortran
    # preprocessor include
    - match: (?xi:^  \s*  \#  \s*  (include|import)  \b  )
      scope: keyword.control.preprocessor.fortran
      push: preprocessor_include
    # preprocessor warning
    - match: (?xi:^  \s*  \#  \s*  (error|warning)  \b  )
      scope: keyword.control.preprocessor.fortran
      push: preprocessor_errorwarning

  namelist:
    # namelist /name/ variables
    - match: (?xi:^  \s*  (namelist)  \s*  (/)(\w+)(/)  \s*  )
      captures:
        0: namelist.statement.fortran
        1: keyword.namelist.fortran
        2: punctuation.namelist-slash.fortran
        3: storage.type.namelist-name.fortran
        4: punctuation.namelist-slash.fortran
      push: namelist-meta

  common-block:
    # common block with name
    - match: (?xi:^  \s*  (common)  \s*  (/\w+/)  \s*  )
      captures:
        0: common.statement.fortran
        1: keyword.common.fortran
        2: storage.type.common-block-name.fortran
      push: common-block-meta
    # common block with no name given
    - match: (?xi:^  \s*  (common)  \s+  )
      captures:
        0: common.statement.fortran
        1: keyword.common.fortran
      push: common-block-meta
  data-statement:
    # data statement
    - match: (?xi:^  \s*  (data)  \s+  (\w+)  \s*  (/))
      captures:
        1: keyword.data.fortran
        2: storage.data.fortran
  block-data-statement:
    # block data statement
    - match: (?xi:^  \s*  (block\s*data)  \s+  (\w+)  )
      captures:
        1: keyword.block-data.fortran
        2: storage.block-data.fortran
      push: blockdata

  public-private-protected:
    # public/private/protected keywords
    - match: (?xi:^  \s*  \b(public|private|protected) \b )
      captures:
        1: keyword.scope.fortran


  coarrays:
    # coarray stuff
    - match: (?xi:^  \s*  \b(sync) \s+ (all|images|memory)\b )
      scope: support.function.coarrays.sync.fortran
    - match: (?xi:(?<=\w) (\[) ([^\]]*) (]) )
      scope: constant.coarrays.fortran

  generic-subroutine-call:
    # generic subroutine call
    - match: (?xi:\b  (call)  \s*  ({{ident}})  \s*  (?=\(|$)  )
      captures:
        1: keyword.call.fortran
        2: meta.subroutine-call.fortran
    # # generic function call (or array access)
    # - match: (?x:({{ident}})  \s*  (?=\()  )
    #   scope: meta.function-call.fortran

    - include: literals
    - include: arithmetic-operators

  associate-block:
    # associate block
    - match: (?xi:^ \s* (associate) (\() (.*) (\)) )
      captures:
        1: keyword.associate.fortran
    - match: (?xi:^ \s* (end\s*associate))
      captures:
        1: keyword.associate.fortran


  literals:
    # floating point literals with an exponent (must come before -+ operators) and optional underscore kind
    - match: |
        (?xi)
        (?:
          (?<![\w\)])                       # previous token is not a word or bracket
          [-+]?                             # sign
          (\d+\.\d+ | \d+\. | \.\d+ | \d+ ) # 1.1 or 1. or .1 or 1
          ([ed][-+]?\d+)?                   # exponent
          (_\w+)?                           # 1.0_fb format
        )
      scope: constant.numeric.floating-point.fortran
    # boolean literals
    - match: (?i:\.true\.|\.false\.)
      scope: constant.language.fortran
    # # numeric literals (without an exponent)
    # - match: \b[0-9.]*\b
    #   scope: constant.numeric.fortran


  arithmetic-operators:
    # arithmetic operators (must come after floating point literals)
    - match: (?x:=  |  -  |  \+  |  /  |  \*  |  //  |  ::)
      scope: keyword.operator.fortran
    # rename import operator/pointer assignment operator
    - match: =>
      scope: keyword.operator.fortran
    # C style comparison operators
    - match: (==|<|>|<=|>=)
      scope: keyword.operator.c-style.fortran
    # logical operators
    - match: (?xi:\.  (and|or|eq|lt|le|gt|ge|ne|not|eqv|neqv)  \.)
      scope: keyword.operator.logical.fortran
    # type member access
    - match: \%
      scope: keyword.operator.member-access.fortran




















  ieee-intrinsics:
    # Intrinsic functions in Fortran 90
    # https://www.nsc.liu.se/~boein/f77to90/a5.html
    # 1. Function which determines if a certain argument is in an actual argument list
    - match: (?x:\b  (?i:present)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 2. Numerical functions
    - match: (?x:\b  (?i:abs|aimag|aint|anint|cmplx|conjg|dble|dim|dprod|int|max|min|mod|nint|real|sign)  \b  (?=\s*\()  )
      scope: support.function.fortran
    - match: (?x:\b  (?i:ceiling|floor|modulo)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 3. Mathematical functions
    - match: (?x:\b  (?i:acos|asin|atan|atan2|cos|cosh|exp|log|log10|sin|sinh|sqrt|tan|tanh)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 4. Character string functions
    - match: (?x:\b  (?i:achar|adjustl|adjustr|char|iachar|ichar|index|len_trim|lge|lgt|lle|llt|repeat|scan|trim|verify)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 5. Character string function for request
    - match: (?x:\b  (?i:len)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 6. Kind functions
    - match: (?x:\b  (?i:kind|selected_int_kind|selected_real_kind)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 7. Logical function
    - match: (?x:\b  (?i:logical)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 8. Numerical inquiry functions
    - match: (?x:\b  (?i:digits|epsilon|huge|maxexponent|minexponent|precision|radix|range|tiny)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 9. Bit inquiry function
    - match: (?x:\b  (?i:bit_size)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 10. Bit manipulation functions
    - match: (?x:\b  (?i:btest|iand|ibclr|ibits|ibset|ieor|ior|ishft|ishftc|not)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 11. Transfer functions
    - match: (?x:\b  (?i:transfer)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 12. Floating-point manipulation functions
    - match: (?x:\b  (?i:exponent|fraction|nearest|rrspacing|scale|set_exponent|spacing)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 13. Vector- and matrix-multiplication functions
    - match: (?x:\b  (?i:dot_product|matmul)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 14. Array functions
    - match: (?x:\b  (?i:all|any|count|maxval|minval|product|sum)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 15. Array inquiry functions
    - match: (?x:\b  (?i:allocated|lbound|shape|size|ubound)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 16. Array construct functions
    - match: (?x:\b  (?i:merge)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 17. ARRAY reshape function
    - match: (?x:\b  (?i:reshape)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 18. ARRAY manipulation functions
    - match: (?x:\b  (?i:cshift|eoshift|transpose)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 19. Array location functions
    - match: (?x:\b  (?i:maxloc|minloc)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 20. Pointer inquiry functions
    - match: (?x:\b  (?i:associated)  \b  (?=\s*\()  )
      scope: support.function.fortran

    # 21. Intrinsic subroutines
    # Time routines / Bit copy routine / Random number routines
    - match: (?x:\b  (call)  \s+  (?i:date_and_time|system_clock|count_max|mvbits|random_number|random_seed)  \b  (?=\s*\()  )
      captures:
        1: keyword.call.fortran
        2: support.function.fortran

  nullify-statement:
    # Nullify statement
    - match: (?x:\b  (?i:nullify)  \b  (?=\s*\()  )
      scope: support.function.fortran

  fortran-2008:
    # Fortran 2008: http://www.nag.co.uk/nagware/np/r60_doc/nag_f2008.html#AUTOTOC_6
    # Mathematics
    - match: (?x:\b  (?i:acosh|asinh|atanh|hypot|norm2|erf|erfc|erfc_scaled|gamma|log_gamma)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # Bit manipulation
    - match: (?x:\b  (?i:bge|bgt|ble|blt|dshiftl|dshiftr|iall|iany|iparity|leadz|trailz|maskl|maskr|merge_bits|parity|popcnt|poppar)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # Other
    - match: (?x:\b  (?i:execute_command_line|storage_size|is_contiguous)  \b  (?=\s*\()  )
      scope: support.function.fortran

    # ISO_FORTRAN_ENV
    - match: (?x:\b  (?i:int8|int16|int32|int64|real32|real64|real128)  \b  )
      scope: support.constant.fortran
    - match: (?x:\b  (?i:character_kinds|integer_kinds|logical_kinds|real_kinds)  \b  )
      scope: support.constant.fortran

  ieee-intrinsic-modules:
    ##########################
    # IEEE Intrinsic Modules #
    ##########################

    # IEEE_ARITHMETIC module
    - match: (?xi:\b ieee_(class_type|round_type) \b)
      scope: support.type.fortran
    # IEEE_CLASS_TYPEs
    - match: (?xi:\b ieee_(signaling_nan|negative_normal|quiet_nan|positive_denormal|positive_inf|negative_denormal|negative_inf|positive_zero|positive_normal|negative_zero|other_value) \b )
      scope: support.constant.fortran
    # IEEE_ROUND_TYPEs
    - match: (?xi:\b ieee_(nearest|to_zero|up|other|down) \b )
      scope: support.constant.fortran

    # IEEE_EXCEPTIONS module
    - match: (?xi:\b ieee_(flag_type|status_type) \b)
      scope: support.type.fortran
    # IEEE_FLAG_TYPEs
    - match: (?xi:\b ieee_(invalid|divide_by_zero|overflow|inexact|underflow|usual|all) \b )
      scope: support.constant.fortran

    # IEEE_FEATURES module
    - match: (?xi:\b ieee_(features_type|status_type) \b)
      scope: support.type.fortran
    # IEEE_FEATURES_TYPEs
    - match: (?xi:\b ieee_(datatype|inf|divide|nan|rounding|inexact_flag|sqrt|invalid_flag|denormal|underflow_flag|halting) \b )
      scope: support.constant.fortran

    # IEEE Procedures
    - match: (?xi:\b ieee_(class|copy_sign) \b )
      scope: support.function.fortran
    - match: (?xi:\b (call) \s* (ieee_(get|set)_(flag|halting_mode|rounding_mode|status|underflow_mode)) \b )
      captures:
        1: keyword.subroutine-call.fortran
        2: support.function.fortran
    - match: (?xi:\b ieee_is_(finite|nan|negative|normal) \b )
      scope: support.function.fortran
    - match: (?xi:\b ieee_(logb|next_after|rem|rint|scalb|selected_real_kind) \b )
      scope: support.function.fortran
    - match: (?xi:\b ieee_support_(datatype|denormal|divide|flag|halting|inf|io|nan|rounding|sqrt|standard|underflow_control) \b )
      scope: support.function.fortran
    - match: (?xi:\b ieee_(unordered|value) \b )
      scope: support.function.fortran



  # additional contexts

  preprocessor_include:
    - meta_scope: meta.preprocessor.fortran.include
    - match: (?=(?://|/\*))|$\n?
      pop: true
    - include: strings
    - match: (<)
      push: include_angle_brackets
  include_angle_brackets:
    - meta_scope: string.quoted.other.lt-gt.include.fortran
    - match: (>)
      pop: true
  preprocessor_errorwarning:
    - meta_scope: meta.preprocessor.diagnostic.fortran
    - match: $\n?
      pop: true


  m4macrostring:
    - meta_scope: string.quoted.m4macro.fortran
    - match: (\')
      pop: true
  singlestring:
    - meta_scope: string.quoted.single.fortran
    - match: \'\'
      scope: constant.character.escape.apostrophe.fortran
    - match: '{{escapeseq}}'
      scope: constant.character.escape.backslash.fortran
    - match: \'
      pop: true
  doublestring:
    - meta_scope: string.quoted.double.fortran
    - match: \"\"
      scope: constant.character.escape.quote.fortran
    - match: '{{escapeseq}}'
      scope: constant.character.escape.backslash.fortran
    - match: \"
      pop: true


  comment:
    - meta_scope: comment.line.fortran
    # Match inline LaTeX
    - match: \$
      push: inline_latex
    - match: $\n?
      pop: true

  inline_latex:
    - meta_scope: meta.inline_latex.fortran
    - meta_content_scope: markup.bold
    - match: \\\w+
      scope: markup.italic
    - match: \$
      pop: true
    - match: $\n?
      pop: true

  subroutine_parameter_list:
    - meta_content_scope: meta.subroutine-parameter-list.fortran
    - match: \w+ # variable name in the parameter list
      scope: variable.parameter.fortran
    # match closing bracket plus result(...)
    - match: (?xi:\) \s* (result)  \s*  \(   \s*  (\w+) \s* \))
      captures:
        1: keyword.function-result.fortran
        2: variable.parameter.fortran
      pop: true
    # match closing bracket only
    - match: \)
      pop: true
  #     set: subroutines # close parameter list scope, push subroutines scope
  # subroutines:
  #   - meta_content_scope: meta.subroutine.fortran
  #   - include: main
  #   - match: (?xi:^  \s*  (end)  ( $ | \s*(function|subroutine) (\s+{{ident}})? )  )
  #     captures:
  #       1: keyword.subroutine-end.fortran
  #       2: storage.type.fortran
  #     pop: true

  namelist-meta:
    - meta_content_scope: meta.namelist.fortran
    - match: ({{ident}})
      scope: variable.parameter.namelist.fortran
    # Don't end the block if the newline is preceded by an &
    - match: \!
      push: comment
    - match: (?<!&)\n
      pop: true

  common-block-meta:
    - meta_content_scope: meta.common-block.fortran
    - match: ({{ident}})
      scope: variable.parameter.common-block-name.fortran
    # Don't end the block if the newline is preceded by an &
    - match: (?<!&)\n
      pop: true

  blockdata:
    - meta_content_scope: meta.common-block.fortran
    - match: \b(?i:end)\b
      pop: true

  # Stuff inside the parenthesis of format strings: print "(.....)"
  formatstring:
    - meta_content_scope: meta.format-string.fortran
    - include: strings
    - match: '{{formatdescr}}'
      scope: constant.numeric.format-descriptor.fortran
    - match: \)\"
      scope: punctuation.end-of-format-string.fortran meta.format-string.fortran
      pop: true

  # variabledeclaration:
  #   - meta_content_scope: meta.variable-declaration.fortran
  #   - include: comments
  #   - match: (?<=\,)\s*((?i:save|implicit|dimension|parameter|allocatable|intent|pointer|target|private|public|protected|contiguous))
  #     captures:
  #       1: keyword.variable-attribute.fortran
  #   - match: (::)
  #     scope: keyword.operator.fortran
  #   - match: $\n?
  #     pop: true

