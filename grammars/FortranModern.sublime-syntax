%YAML 1.2
---
name: Fortran (Modern)
file_extensions: [f90, F90, f95, F95, f03, F03, f08, F08]
scope: source.modern-fortran

variables:
  ident: '[A-Za-z_][A-Za-z_0-9]*'
  modifier: '(?xi:elemental|pure|impure|recursive|module)'
  # attr_spec: |
  #   (?xi)
  #   (?:
  #       allocatable
  #     | asynchronous
  #     | automatic
  #     | bind \s* \( \s* C \s* (, \s* name \s* = \s* {{binding_label}})? \)
  #     | contiguous
  #     | dimension \s* \( {{array_spec}} \)
  #     | external
  #     | intent(intn...)
  #     | intrinsic
  #     | optional
  #     | parameter
  #     | pointer
  #     | private
  #     | protected
  #     | public
  #     | save
  #     | target
  #   )
  attribute: |
    (?xi)
    (?:
        allocatable
      | pointer
      | target
      | equivalence
      | parameter
      | external
      | intrinsic
      | save
      | optional
      | contiguous
      | private
      | public
      | protected
    )
  # linecont: '(?x:\s* & \s* (!.*)? $)' # matches possible space, amersand, possible space, possible comment, end of line, possible newline
  formatdescr: (?xi:(\d+)?  (/|pe|[aeigfxp])  (\d+)?  \.?  (\d+)? )
  escapeseq: (?xi:\\ [nrtbfv0''"x\\] )

  int_constant_expr: (?xi:\d+|\w+) # only literals and variables supported so far
  int_literal_constant: (?xi:\d+)
  kind_selector: |
    (?xi)
    (?:
      \s*
      (?:
        \(  (?:\s* kind \s* = \s* )?  {{int_constant_expr}} \)
      |
        \* \s* {{int_literal_constant}}
      )
      \s*
    )
  specification_expression: (?xi:TODO_NOT_IMPLEMENTED|\d+)
  type_param_value: | # incomplete
    (?xi:)
    (?:
      {{specification_expression}}
    |
      \*
    |
      :
    )
  char_length: |
    (?xi)
    (?:
      {{int_literal_constant}}
    |
      \( {{type_param_value}} \)
    )
  char_selector: | # incomplete
    (?xi)
    (?:
      \(
        \s*
        (?:
          LEN \s* = \s* {{type_param_value}} \s* , \s* KIND \s* = \s* {{int_constant_expr}}
        |
          {{type_param_value}} \s* ,  \s* (?:KIND \s* =)?  \s* {{int_constant_expr}}
        |
          KIND \s* = \s* {{int_constant_expr}}  \s* (?: , \s* LEN \s* = \s* {{type_param_value}})?
        |
          (?:LEN \s* = \s* )? {{type_param_value}}
        )
        \s*
      \)
    |
      \s* \* \s* {{char_length}} \s* ,? \s*
    )
  intrinsic_type_spec: |
    (?xi)
    (?:
      \bCHARACTER\b \s* {{char_selector}}
    |
      \b(?:COMPLEX|INTEGER|LOGICAL|REAL)\b (?:\s* {{kind_selector}})?
    |
      \b DOUBLE \s+ (?:COMPLEX|PRECISION) \b
    )
  derived_type_spec: | # missing type_param_spec_list
    (?xi)
    (?:
      {{ident}}
    )
  declaration_type_spec_part1: |
    (?xi)
    (?:
      {{intrinsic_type_spec}}
    |
      type \s* \( \s* {{intrinsic_type_spec}} \s* \)
    |
      type \s* \( \s* {{derived_type_spec}} \s* \)
    |
      class \s* \( \s* {{derived_type_spec}} \s* \)
    |
      class \s* \( \s* \* \s* \)
    )
  declaration_type_spec: | # TODO not used yet
    (?xi)
    (?:
      {{declaration_type_spec_part1}}
      (
        \s* :: \s*
      |
        \s* , {{attr_spec_list}} \s* :: \s*
      )?
      {{entity_decl_list}}
    )

  construct_name: (?xi:{{ident}} \s* (?=:)) # do/if statement label (a valid identifier followed by colon)
  stmt_label: (?xi:\b \d+ \b) # a statement label (a number)











contexts:
  main:
    - include: Packages/SublimeFortran/grammars/OpenMP.sublime-syntax
    - include: comments
    - include: illegal
    - include: m4-macros
    - include: strings
    - include: use-statement
    - include: implicit-statement
    - include: enumerator
    - include: associate-block
    - include: block
    - include: flow-control
    - include: program-units
    - include: misc-keywords
    - include: user-defined-types
    - include: format-statement
    - include: labelled-statements
    - include: data-type-attributes
    - include: io
    - include: allocation
    - include: preprocessor
    - include: namelist
    - include: common-block
    - include: data-statement
    - include: block-data-statement
    - include: public-private-protected
    - include: coarrays
    - include: ieee-intrinsics
    - include: nullify-statement
    - include: fortran-2008
    - include: ieee-intrinsic-modules
    - include: generic-subroutine-call

  comments:
    # comments
    - match: \!
      push: comment
  illegal:
    # tabs are illegal
    - match: \t
      scope: invalid.illegal.tab.fortran

  m4-macros:
    # M4 macro quoted strings, comments, variables and macro definitions
    - match: \`
      push: m4macrostring
    - match: (?x:\b dnl \b )
      push: comment
    - match: \$\d+
      scope: variable.parameter.m4.fortran
    - match: |
        (?x)
        (?:
          \b
          (define)
          \(
          \s*
          `(\w+)'
        )
      captures:
        1: keyword.m4.define.fortran
        2: entity.name.function.m4.fortran

  strings:
    - match: \'
      push: singlestring
    - match: (\")
      push: doublestring

  use-statement:
    # use statements etc
    - match: |
        (?xi)
        (?:^
          \s* (use)
          \s+ (\w+)
          ( (,) \s* (only) \s* (:) )?
        )
      captures:
        0: use.statement.fortran
        1: keyword.use.fortran
        2: storage.type.module.fortran
        3: optional.group.use.statement.fortran
        5: keyword.only.fortran

  implicit-statement:
    # implicit statement
    - match: |
        (?xi)
        (?:
          (implicit)
          \s+
          (none|.*)
        )
      captures:
        0: implicit.statement.fortran
        1: keyword.implicit.fortran
        2: meta.implicit-specification.fortran


  enumerator:
    # enum
    - match: |
        (?xi)
        (?:^
          \s* (
            enum
            (,\s*bind\(c\))?)
          \s*
          $
        )
      captures:
        1: keyword.enum.fortran

    - match: (?xi:\b enumerator \b)
      scope: keyword.enumerator.fortran
    # end enum
    - match: (?xi:^  \s*  (endenum) \b)
      captures:
        1: keyword.enum.fortran

  program-units:
    # program definition
    - match: |
        (?xi)
        (?:^
          \s* (program)
          \s+ ({{ident}})
        )
      captures:
        1: keyword.program-unit.fortran
        2: entity.name.function.program.fortran

    # type definition
    - match: |
        (?xi)
        (?:^
          \s* (type)
          (\s*::\s*|\s+)
          ({{ident}})
        )
      captures:
        1: keyword.type.fortran
        2: keyword.operator.fortran
        3: entity.name.function.type.fortran

    # module definition
    - match: |
        (?xi)
        (?:^
          \s* (module)
          \s+  (\w+)
        )
      captures:
        1: keyword.program-unit.fortran
        2: entity.name.function.module.fortran

    # submodule definition
    - match: |
        (?xi)
        (?:^
          \s* (submodule)
          \s* \( ({{ident}}) \)
          \s* ({{ident}})
          \s*
          $
        )
      captures:
        1: keyword.submodule.fortran
        2: variable.other.module.fortran
        3: entity.name.function.module.fortran

    # interface with name
    - match: |
        (?xi)
        (?:
          ^ \s*
          (interface) \b
          \s* ({{ident}})?
        )
      captures:
        1: keyword.program-unit.fortran
        2: entity.name.function.fortran
      # push: interface

    # function/subroutine definition with parameter list
    - match: |
        (?xi)
        (?:^
          \s*
          ((?:{{modifier}}\s+)*)
          ({{declaration_type_spec_part1}}\s+)?
          \b (FUNCTION|SUBROUTINE) \b
          \s+ ({{ident}})
          \s* (\(|&) # match opening bracket
        )
      scope: meta.subroutine-declaration.fortran
      captures:
        1: keyword.modifier.fortran
        2: storage.type.fortran
        3: keyword.program-unit.fortran
        4: entity.name.function.fortran
      push: subroutine_parameter_list

    # function/subroutine definition without parameter list
    - match: |
        (?xi)
        (?:^
          \s*
          ((?:{{modifier}}\s+)*)
          ({{declaration_type_spec_part1}}\s+)?
          \b (FUNCTION|SUBROUTINE) \b
          \s+ ({{ident}})
          \s*
        )
      captures:
        0: meta.subroutine-declaration.fortran
        1: keyword.modifier.fortran
        2: storage.type.fortran
        3: keyword.program-unit.fortran
        4: entity.name.function.fortran
      # push: subroutines

    # end with block type and possible identifier
    - match: |
        (?xi)
        (?:^
          \s* (end)
          (
            \s*
            (?:function|subroutine|module|submodule|type|interface|program|type|select)
            ( \s+ {{ident}} )?
          )?
          \s*     # optional space
          (!.*)?  # optional comment
          $       # end of line
        )
      scope: meta.end-statement.fortran
      captures:
        1: keyword.control.end.fortran
        2: keyword.program-unit.fortran
        3: entity.name.function.fortran
        4: comment.line.fortran




  flow-control:
    # do_while_statement (must come before do_statement)
    - match: |
        (?xi)
        (?:^ \s*
          (?: ({{construct_name}}) : )?         # 1 optional do statement label
          \s* \b (do) \b                        # 2 do keyword
          \s* ({{stmt_label}})?                 # 3 statement label with comma
          \s* ,?                                #   optional comma
          \s* \b (while) \b                     # 4 while keyword
          (?= \s* \( )                          #   lookahead to expect opening parenthesis
          # Can't use this stuff:
          # \s* \(                                #   opening parenthesis
          #         .*                            #   logical scalar expression
          # \s* \)                                #   closing parenthesis
        )
      scope: meta.do_while_statement.fortran
      captures:
        1: entity.name.tag.construct_name.fortran
        2: keyword.control.fortran
        3: entity.name.statement-label.fortran constant.numeric
        4: keyword.control.fortran
    # do_statement
    - match: |
        (?xi)
        (?:^ \s*
          (?: ({{construct_name}}) : )?         # optional do statement label
          \s* \b (do|do \s+ concurrent) \b      # do keyword
          \s* ({{stmt_label}})?                 # statement label with comma
          \s* (?:
                ,?                              # optional comma
                \s* ({{ident}})                 # loop variable name
                \s* (=)                         # equals sign
                # Can't match this stuff due to lack of regex for an expression
                # \s* an_expr_                  # expression 1
                # \s* ,                         # comma
                # \s* an_expr_                  # expression 2
                # (
                #   \s* ,
                #   \s* an_expr_                # expression 3
                # )?
              )?
        )
      scope: meta.do_statement.fortran
      captures:
        1: entity.name.tag.construct_name.fortran
        2: keyword.control.fortran
        3: entity.name.statement-label.fortran constant.numeric
        4: variable.do_loop_variable.fortran
        5: keyword.operator.fortran
    
    # block_if_statement
    - match: |
        (?xi)
        (?:^ \s*
          (?: ({{construct_name}}) : )?         # 1 optional if statement label
          \s* \b (if) \b                        # 2 if keyword
          (?= \s* \( )                          #   lookahead to expect opening parenthesis
          # Can't match this stuff due to lack of regex for an expression
          # \s* \(                                #   opening parenthesis
          #         .*                            #   logical scalar expression
          # \s* \)                                #   closing parenthesis
          # \s* \b (then) \b                      # 3 then keyword
        )
      scope: meta.block_if_statement.fortran
      captures:
        1: entity.name.tag.construct_name.fortran
        2: keyword.control.fortran

    # end_do_statement and end_if_statement
    - match: (?xi:^ \s* (end) \s* (do|if) \b (?:\s+ ({{ident}}) )? )
      captures:
        0: meta.end-statement.fortran
        1: keyword.control.fortran
        2: keyword.control.fortran
        3: entity.name.tag.construct_name.fortran


    # GOTO statement
    - match: (?xi:^ \s* (go) \s* (to) \s+ (\d+) )
      captures:
        1: keyword.control.fortran
        2: keyword.control.fortran
        3: entity.name.statement-label

    # statements controling the flow of the program
    - match: |
        (?xi)
        (?:
          \b( assign
            | to
            | then
            | else
            | elseif
            | elif
            | case\s+default
            | case
            | continue
            | stop
            | pause
            | while
            | cycle
            | exit
            | select \s* case
            | error \s+ stop
            | end \s* if
            | where
            | elsewhere
            | forall
            | end \s* where
            | end \s* forall
            | go \s+ to
            ) \b
        )
      scope: keyword.control.fortran













  misc-keywords:
    # contains
    - match: (?xi:\b contains \b)
      scope: keyword.other.contains.fortran
    # programming units
    - match: \b(?i:(entry|return|include))\b
      scope: keyword.control.programming-units.fortran
    # other
    - match: \b(?i:(operator|assignment))\b
      scope: storage.type.fortran

  user-defined-types:
    # types
    - match: "{{declaration_type_spec_part1}}"
      scope: storage.type.fortran



  labelled-statements:
    # continue label, possibly numbered
    - match: (?xi:^  \s*  (\d+)?  \s*  (continue)  \s*  $)
      captures:
        0: meta.continue-label.fortran
        1: entity.name.statement-label.fortran
        2: keyword.continue.fortran
    # labeled statement
    - match: ^(    \d|   \d\d|  \d\d\d)
      scope: entity.name.statement-label.fortran
    # goto statement
    - match: (?xi:\b  (go\s*to)  \s+  (\d+))
      captures:
        1: keyword.goto.fortran
        2: entity.name.statement-label.fortran


  data-type-attributes:
    # data type attributes
    - match: \b(?i:{{attribute}})\b
      scope: storage.modifier.fortran
    # dimension statement
    - match: (?xi:^  \s*  (dimension)  \b  )
      captures:
        1: storage.modifier.fortran
    # variable dimension
    - match: (?xi:\b  (dimension)  \s* \(  [^)]*  \)  )
      captures:
        0: meta.dimension.fortran
        1: storage.modifier.fortran
    # variable intent
    - match: (?xi:\b  (intent)  \s* \(  \s*  (in|out|inout)  \s*  \)  )
      captures:
        0: meta.intent.fortran
        1: keyword.intent.fortran
        2: constant.language.fortran

  io:
    # IO: open, close
    - match: (?xi:\b  (close|open)  \s*  \(  )
      captures:
        1: support.function.fortran

    # IO: print with format string
    - match: (?xi:\b(print)\b  \s*  ( \") )
      captures:
        1: support.function.fortran
        2: string.quoted.double.fortran
      push: inside-format-string
    # IO: print with format string variable or star or number
    - match: (?xi:\b  (print)\b  \s*  (\*)? (\d+)? (\w+)? )
      captures:
        1: support.function.fortran
        2: keyword.default-format.fortran
        3: variable.format-number.fortran
        4: variable.format-string.fortran
    # IO: write with (unit number|string variable) and format string
    - match: (?xi:\b  (write)  \s*  (\() (\d+|{{ident}}) \s* , \s*      ( \"\( )  )
      captures:
        1: support.function.fortran
        2: punctuation.parenthesis.fortran
        3: variable.write-destination.fortran
        4: punctuation.start-of-format-string.fortran meta.format-string.fortran
      push: formatstring
    # IO: write with (unit number|string variable) and format string variable or star or number
    - match: (?xi:\b  (write)  \s*  (\() (\*|\d+|{{ident}}) \s* , \s*      (\*)? (\d+)? (\w+)? )
      captures:
        1: support.function.fortran
        2: punctuation.parenthesis.fortran
        3: variable.write-destination.fortran
        4: keyword.default-format.fortran
        5: variable.format-number.fortran
        6: variable.format-string.fortran

    # IO: print, write, rewrite, read
    - match: (?xi:\b  (print|write|rewrite|read)\b  \s*  (?= ( \( | \* | \d+ ) )  )
      captures:
        1: support.function.fortran

    # IO: pause, wait, rewind, flush, inquire
    - match: (?xi:\b  (pause|wait|rewind|flush|inquire)  \s*  \(  )
      captures:
        1: support.function.fortran


  format-statement:
    # IO: format statement
    - match: (?xi:^  \s*  (\d+)  \s+  (format)  \s*  (\()  )
      captures:
        1: entity.name.statement-label.fortran
        2: keyword.format.fortran
        3: open-format-group.fortran
      push: inside-format-group

    # # IO: other format string
    # - match: (\")(\() # "( ... )"
    #   captures:
    #     1: punctuation.start-of-format-string.fortran
    #     2: open-format-group.fortran
    #   push: inside-format-group

  inside-format-string:
    - meta_content_scope: meta.inside-format-string.fortran
    - match: \(
      scope: open-format-group.fortran
      push: inside-format-group
    - match: \"
      scope: string.quoted.double close-format-string.fortran
      pop: true
  inside-format-group:
    # Represents the content between two () in a format group
    - meta_content_scope: meta.inside-format-group.fortran
    - include: strings
    - match: \(
      scope: open-format-group.fortran
      push: inside-format-group
    - match: '\d+(?=\()'
      scope: constant.numeric.format-string-group-multiplier.fortran
    - match: \)
      pop: true
      scope: close-format-group
    - match: '{{formatdescr}}'
      scope: constant.numeric.format-descriptor.fortran





  allocation:
    # allocate, deallocate
    - match: (?xi:\b  (allocate|deallocate)  \b  \s*  \(  \s*  (\w+)  )
      captures:
        1: support.function.fortran
        2: variable.other.fortran

  preprocessor:
    # preprocessor logic
    - match: (?xi:^  \s*  \#  \s*  (define|undef|if|ifdef|elif|ifndef|else|endif)  \b  .*  $)
      scope: keyword.control.preprocessor.fortran
    # preprocessor include
    - match: (?xi:^  \s*  \#  \s*  (include|import)  \b  )
      scope: keyword.control.preprocessor.fortran
      push: preprocessor_include
    # preprocessor warning
    - match: (?xi:^  \s*  \#  \s*  (error|warning)  \b  )
      scope: keyword.control.preprocessor.fortran
      push: preprocessor_errorwarning

  namelist:
    # namelist /name/ variables
    - match: (?xi:^  \s*  (namelist)  \s*  (/)({{ident}})(/) )
      captures:
        0: namelist.statement.fortran
        1: keyword.namelist.fortran
        2: punctuation.namelist-slash.fortran
        3: entity.name.namelist.fortran
        4: punctuation.namelist-slash.fortran
      push: namelist-meta

  common-block:
    # common block with name
    - match: (?xi:^  \s*  (common)  \s*  (/)({{ident}})(/) )
      captures:
        0: common.statement.fortran
        1: keyword.common.fortran
        2: punctuation.common-slash.fortran
        3: entity.name.common.fortran
        4: punctuation.common-slash.fortran
      push: namelist-meta
    # common block with no name given
    - match: (?xi:^  \s*  (common)  \s+  )
      captures:
        0: common.statement.fortran
        1: keyword.common.fortran
      push: namelist-meta
  data-statement:
    # data statement
    - match: (?xi:^  \s*  (data)  \s+  (\w+)  \s*  (/))
      captures:
        1: keyword.data.fortran
        2: storage.data.fortran
  block-data-statement:
    # block data statement
    - match: (?xi:^  \s*  (block\s*data)  \s+  (\w+)  )
      captures:
        1: keyword.block-data.fortran
        2: storage.block-data.fortran
      push: blockdata

  public-private-protected:
    # public/private/protected keywords
    - match: (?xi:^  \s*  \b(public|private|protected) \b )
      captures:
        1: keyword.scope.fortran


  coarrays:
    # coarray stuff
    - match: (?xi:\b codimension \b)
      scope: keyword.coarrays.fortran
    - match: (?xi:^  \s*  \b(sync) \s+ (all|images|memory)\b )
      scope: support.function.coarrays.sync.fortran
    # - match: (?xi:(?<=\w) (\[) ([^\]]*) (]) ) # remove backreference
    #   scope: constant.coarrays.fortran

  generic-subroutine-call:
    # generic subroutine call
    - match: (?xi:\b  (call)  \s*  ({{ident}})  \s*  (?=\(|$)  )
      captures:
        1: keyword.call.fortran
        2: meta.subroutine-call.fortran
    # # generic function call (or array access)
    # - match: (?x:({{ident}})  \s*  (?=\()  )
    #   scope: meta.function-call.fortran

    - include: literals
    - include: arithmetic-operators

  associate-block:
    # associate block
    - match: (?xi:^ \s* (associate) (\() (.*) (\)) )
      captures:
        1: keyword.associate.fortran
    - match: (?xi:^ \s* (end\s*associate))
      captures:
        1: keyword.associate.fortran
  block:
    # block
    - match: (?xi:^ \s* (block)\b)
      captures:
        1: keyword.block.fortran
    - match: (?xi:^ \s* (end\s*block)\b)
      captures:
        1: keyword.block.fortran


  literals:
    # floating point literals with an exponent (must come before -+ operators) and optional underscore kind
    - match: |
        (?xi)
        (?:
          (?<![\w\)])                       # previous token is not a word or bracket
          [-+]?                             # sign
          (\d+\.\d+ | \d+\. | \.\d+ | \d+ ) # 1.1 or 1. or .1 or 1
          ([ed][-+]?\d+)?                   # exponent
          (_\w+)?                           # 1.0_fb format
        )
      scope: constant.numeric.floating-point.fortran
    # boolean literals
    - match: (?i:\.true\.|\.false\.)
      scope: constant.language.fortran
    # # numeric literals (without an exponent)
    # - match: \b[0-9.]*\b
    #   scope: constant.numeric.fortran


  arithmetic-operators:
    # arithmetic operators (must come after floating point literals)
    - match: (?x:=  |  -  |  \+  |  /  |  \*  |  //  |  ::)
      scope: keyword.operator.fortran
    # rename import operator/pointer assignment operator
    - match: =>
      scope: keyword.operator.fortran
    # C style comparison operators
    - match: (==|<|>|<=|>=)
      scope: keyword.operator.c-style.fortran
    # logical operators
    - match: (?xi:\.  (and|or|eq|lt|le|gt|ge|ne|not|eqv|neqv)  \.)
      scope: keyword.operator.logical.fortran
    # type member access
    - match: \%
      scope: keyword.operator.member-access.fortran




















  ieee-intrinsics:
    # Intrinsic functions in Fortran 90
    # https://www.nsc.liu.se/~boein/f77to90/a5.html
    # 1. Function which determines if a certain argument is in an actual argument list
    - match: (?x:\b  (?i:present)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 2. Numerical functions
    - match: (?x:\b  (?i:abs|aimag|aint|anint|cmplx|conjg|dble|dim|dprod|int|max|min|mod|nint|real|sign)  \b  (?=\s*\()  )
      scope: support.function.fortran
    - match: (?x:\b  (?i:ceiling|floor|modulo)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 3. Mathematical functions
    - match: (?x:\b  (?i:acos|asin|atan|atan2|cos|cosh|exp|log|log10|sin|sinh|sqrt|tan|tanh)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 4. Character string functions
    - match: (?x:\b  (?i:achar|adjustl|adjustr|char|iachar|ichar|index|len_trim|lge|lgt|lle|llt|repeat|scan|trim|verify)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 5. Character string function for request
    - match: (?x:\b  (?i:len)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 6. Kind functions
    - match: (?x:\b  (?i:kind|selected_int_kind|selected_real_kind)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 7. Logical function
    - match: (?x:\b  (?i:logical)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 8. Numerical inquiry functions
    - match: (?x:\b  (?i:digits|epsilon|huge|maxexponent|minexponent|precision|radix|range|tiny)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 9. Bit inquiry function
    - match: (?x:\b  (?i:bit_size)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 10. Bit manipulation functions
    - match: (?x:\b  (?i:btest|iand|ibclr|ibits|ibset|ieor|ior|ishft|ishftc|not)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 11. Transfer functions
    - match: (?x:\b  (?i:transfer)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 12. Floating-point manipulation functions
    - match: (?x:\b  (?i:exponent|fraction|nearest|rrspacing|scale|set_exponent|spacing)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 13. Vector- and matrix-multiplication functions
    - match: (?x:\b  (?i:dot_product|matmul)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 14. Array functions
    - match: (?x:\b  (?i:all|any|count|maxval|minval|product|sum)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 15. Array inquiry functions
    - match: (?x:\b  (?i:allocated|lbound|shape|size|ubound)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 16. Array construct functions
    - match: (?x:\b  (?i:merge)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 17. ARRAY reshape function
    - match: (?x:\b  (?i:reshape)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 18. ARRAY manipulation functions
    - match: (?x:\b  (?i:cshift|eoshift|transpose)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 19. Array location functions
    - match: (?x:\b  (?i:maxloc|minloc)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # 20. Pointer inquiry functions
    - match: (?x:\b  (?i:associated)  \b  (?=\s*\()  )
      scope: support.function.fortran

    # 21. Intrinsic subroutines
    # Time routines / Bit copy routine / Random number routines
    - match: (?x:\b  (call)  \s+  (?i:date_and_time|system_clock|count_max|mvbits|random_number|random_seed)  \b  (?=\s*\()  )
      captures:
        1: keyword.call.fortran
        2: support.function.fortran

  nullify-statement:
    # Nullify statement
    - match: (?x:\b  (?i:nullify)  \b  (?=\s*\()  )
      scope: support.function.fortran

  fortran-2008:
    # Fortran 2008: http://www.nag.co.uk/nagware/np/r60_doc/nag_f2008.html#AUTOTOC_6
    # Mathematics
    - match: (?x:\b  (?i:acosh|asinh|atanh|hypot|norm2|erf|erfc|erfc_scaled|gamma|log_gamma)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # Bit manipulation
    - match: (?x:\b  (?i:bge|bgt|ble|blt|dshiftl|dshiftr|iall|iany|iparity|leadz|trailz|maskl|maskr|merge_bits|parity|popcnt|poppar)  \b  (?=\s*\()  )
      scope: support.function.fortran
    # Other
    - match: (?x:\b  (?i:execute_command_line|storage_size|is_contiguous)  \b  (?=\s*\()  )
      scope: support.function.fortran

    # ISO_FORTRAN_ENV
    - match: (?x:\b  (?i:int8|int16|int32|int64|real32|real64|real128)  \b  )
      scope: support.constant.fortran
    - match: (?x:\b  (?i:character_kinds|integer_kinds|logical_kinds|real_kinds)  \b  )
      scope: support.constant.fortran

  ieee-intrinsic-modules:
    ##########################
    # IEEE Intrinsic Modules #
    ##########################

    # IEEE_ARITHMETIC module
    - match: (?xi:\b ieee_(class_type|round_type) \b)
      scope: support.type.fortran
    # IEEE_CLASS_TYPEs
    - match: (?xi:\b ieee_(signaling_nan|negative_normal|quiet_nan|positive_denormal|positive_inf|negative_denormal|negative_inf|positive_zero|positive_normal|negative_zero|other_value) \b )
      scope: support.constant.fortran
    # IEEE_ROUND_TYPEs
    - match: (?xi:\b ieee_(nearest|to_zero|up|other|down) \b )
      scope: support.constant.fortran

    # IEEE_EXCEPTIONS module
    - match: (?xi:\b ieee_(flag_type|status_type) \b)
      scope: support.type.fortran
    # IEEE_FLAG_TYPEs
    - match: (?xi:\b ieee_(invalid|divide_by_zero|overflow|inexact|underflow|usual|all) \b )
      scope: support.constant.fortran

    # IEEE_FEATURES module
    - match: (?xi:\b ieee_(features_type|status_type) \b)
      scope: support.type.fortran
    # IEEE_FEATURES_TYPEs
    - match: (?xi:\b ieee_(datatype|inf|divide|nan|rounding|inexact_flag|sqrt|invalid_flag|denormal|underflow_flag|halting) \b )
      scope: support.constant.fortran

    # IEEE Procedures
    - match: (?xi:\b ieee_(class|copy_sign) \b )
      scope: support.function.fortran
    - match: (?xi:\b (call) \s* (ieee_(get|set)_(flag|halting_mode|rounding_mode|status|underflow_mode)) \b )
      captures:
        1: keyword.subroutine-call.fortran
        2: support.function.fortran
    - match: (?xi:\b ieee_is_(finite|nan|negative|normal) \b )
      scope: support.function.fortran
    - match: (?xi:\b ieee_(logb|next_after|rem|rint|scalb|selected_real_kind) \b )
      scope: support.function.fortran
    - match: (?xi:\b ieee_support_(datatype|denormal|divide|flag|halting|inf|io|nan|rounding|sqrt|standard|underflow_control) \b )
      scope: support.function.fortran
    - match: (?xi:\b ieee_(unordered|value) \b )
      scope: support.function.fortran


  preprocessor_include:
    - meta_scope: meta.preprocessor.fortran.include
    - match: (?=(?://|/\*))|$
      pop: true
    - include: strings
    - match: (<)
      push: include_angle_brackets
  include_angle_brackets:
    - meta_scope: string.quoted.other.lt-gt.include.fortran
    - match: (>)
      pop: true
  preprocessor_errorwarning:
    - meta_scope: meta.preprocessor.diagnostic.fortran
    - match: $
      pop: true


  m4macrostring:
    - meta_scope: string.quoted.m4macro.fortran
    - match: (\')
      pop: true
  singlestring:
    - meta_scope: string.quoted.single.fortran
    - match: \'\'
      scope: constant.character.escape.apostrophe.fortran
    - match: '{{escapeseq}}'
      scope: constant.character.escape.backslash.fortran
    - match: \'
      pop: true
  doublestring:
    - meta_scope: string.quoted.double.fortran
    - match: \"\"
      scope: constant.character.escape.quote.fortran
    - match: '{{escapeseq}}'
      scope: constant.character.escape.backslash.fortran
    - match: \"
      pop: true


  comment:
    - meta_scope: comment.line.fortran
    # Match inline LaTeX
    - match: \$
      push: inline_latex
    - match: (?=$)
      pop: true

  inline_latex:
    - meta_scope: meta.inline_latex.fortran
    - meta_content_scope: markup.bold
    - match: \\\w+
      scope: markup.italic
    - match: \$
      pop: true
    - match: $
      pop: true

  subroutine_parameter_list:
    - meta_content_scope: meta.subroutine-parameter-list.fortran
    - match: \w+ # variable name in the parameter list
      scope: variable.parameter.fortran
    # match closing bracket plus result(...)
    - match: (?xi:\) \s* (result)  \s*  \(   \s*  (\w+) \s* \))
      captures:
        1: keyword.function-result.fortran
        2: variable.parameter.fortran
      pop: true
    # match closing bracket only
    - match: \)
      pop: true
  #     set: subroutines # close parameter list scope, push subroutines scope
  # subroutines:
  #   - meta_content_scope: meta.subroutine.fortran
  #   - include: main
  #   - match: (?xi:^  \s*  (end)  ( $ | \s*(function|subroutine) (\s+{{ident}})? )  )
  #     captures:
  #       1: keyword.subroutine-end.fortran
  #       2: storage.type.fortran
  #     pop: true

  # This is a generic list of variables, used by namelist, common, etc
  namelist-meta:
    - meta_content_scope: meta.namelist.fortran
    - include: pop-at-end-of-line
    - match: ({{ident}})
      scope: variable.parameter.namelist.fortran

  # Include this to avoid popping the context when there is a line continuation
  pop-at-end-of-line:
    # Match a comment character without a line continuation -> change context to comment
    - match: \!
      set: comment
    - match: (?=\&)
      push: line-continuation
    - match: $\n
      pop: true

  # Consume comments and newline then pop
  line-continuation:
    - meta_scope: meta.line-continuation.fortran
    - match: \&
      scope: support.constant.line-continuation.fortran
    - include: comments
    - match: $\n
      pop: true

  blockdata:
    - meta_content_scope: meta.common-block.fortran
    - match: \b(?i:end)\b
      pop: true

  # Stuff inside the parenthesis of format strings: print "(.....)"
  formatstring:
    - meta_content_scope: meta.format-string.fortran
    - include: strings
    - match: '{{formatdescr}}'
      scope: constant.numeric.format-descriptor.fortran
    - match: \)\"
      scope: punctuation.end-of-format-string.fortran meta.format-string.fortran
      pop: true

  # variabledeclaration:
  #   - meta_content_scope: meta.variable-declaration.fortran
  #   - include: comments
  #   - match: (?<=\,)\s*((?i:save|implicit|dimension|parameter|allocatable|intent|pointer|target|private|public|protected|contiguous))
  #     captures:
  #       1: keyword.variable-attribute.fortran
  #   - match: (::)
  #     scope: keyword.operator.fortran
  #   - match: $
  #     pop: true

